### 主备延迟计算
- 从库连接主库时，会执行`SELECT UNIX_TIMESTAMP()`获取当前主库的系统时间
- 每个事务的binlog 里面都有一个时间字段，用于记录主库上写入的时间
- 备库取出当前正在执行的事务的时间字段的值，计算它与当前系统的时间的差值

### 主备延迟来源
- 备库机器性能弱于主库机器
- 备库压力大，备库上的查询耗费大量的CPU资源，影响同步速度
- 大事务，主库10分钟的大事务，从库也需要10分钟
    - 一次性delete语句删除太多数据
    - 大表DDL

### 主备流程
![](http://image.heysq.com/wiki/mysql/zhubeiliucheng.png)

### 从库并行复制能力
![](http://image.heysq.com/wiki/mysql/worker_fenfa.png)
- 不能造成覆盖更新，要求更新同一行的两个事务，必须被分发到同一个worker中
- 同一个事务不能被拆开，必须放到同一个worker中

### 分发策略
- 按表分发
- 按行分发
- 按库分发
- 按组分发

### 按库分发
- MySQL5.6之后的并行复制策略
- 按库并行
- 不要求binlog格式

### 按组分发
- 模仿 redo log 组提交
- 能够在同一组里提交的事务，一定不会修改同一行，如果修改同一行commit的时候就会被锁住，等待锁的事务会等待不会进入commit状态
- 主库上可以并行执行的事务，备库上一定也是可以并行执行的
- 一个组里边提交的事务，有一个相同的commit id
- binlog中写入 commit id
- 相同的commit id的事务被分发的多个worker进行执行
- 一个组的commit执行完后，再取下一个组

#### 缺点
- 一个组执行时，后续的组只能等着，吞吐量不够
- 遇到大事务，一个组里的其他worker，只能等待大事务的worker执行完，才进行下一个组
