### 定点数表示
- `BCD 编码`

### BCD 编码
- 用 4 个比特来表示 0～9 的整数，那么 32 个比特就可以表示 8 个这样的整数
- 把最右边的 2 个 0～9 的整数，当成小数部分；把左边 6 个 0～9 的整数，当成整数部分
- 就可以用 32 个比特，来表示从 0 到 999999.99 这样 1 亿个实数
- 用二进制来表示十进制数字的方式叫做 `BCD`编码

#### BCD缺点
- 浪费数据范围，32 个比特我们可以表示 40 亿个不同的数，但是在 BCD 编码下，只能表示 1 亿个数
- 没办法同时表示很大的数字和很小的数字

### 浮点数表示
- 科学计数法
- 32位单精度浮点数 `float`或`float32`
- 64位双精度浮点数 `double`或`float64`

#### 单精度浮点数
- IEEE754国际标准规定，32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M
![](/images/jsjzc/danjingdu.png)

- (-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。
- M表示有效数字，大于等于1，小于2。
- 2^E表示指数位。
![](/images/jsjzc/ieee754fudianshu.png)


#### 双精度浮点数
- 对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M
![](/images/jsjzc/shuangjingdu.png)

#### IEEE规定对M的规定
- 1≤M<2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分
- 比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字

#### IEEE对E的规定
- E为一个无符号整数（unsigned int）
- 如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047
- 科学计数法中的E是可以出现负数的，所以IEEE 754规定，E的真实值必须再减去一个中间数
- 对于8位的E，这个`中间数是127`；对于11位的E，这个`中间数是1023`
- 2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001

#### E的额外情况
- E不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1
- E全为0。这时，浮点数的指数E等于1-127（或者1-1023），有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字
- E全为1。这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）
![](/images/jsjzc/fudianshunan.jpeg)

### 小数换成二进制方式
- 小数部分转换成二进制是用一个相似的反方向操作，就是乘以 2，然后看看是否超过 1
- 如果超过 1，我们就记下 1，并把结果减去 1，进一步循环操作
- 如果不超过1，就记下0

#### 0.1转成二进制
![](/images/jsjzc/01erjinzhi.jpeg)
#### 9.1 二进制
- 1001.000110011…这样一个二进制表示
- 转成浮点数表示方式`1.001000110011...*2^3`
- 指数为3，然后加127为8位指数位
- 010000010 0010 0011001100110011 001

### 浮点数相加
- 先对齐指数位、再计算
- 对应的有效位也要调整
> 比如 0.5，表示成浮点数，对应的指数位是 -1，有效位是 00…（后面全是 0，记住 f 前默认有一个 1）。0.125 表示成浮点数，对应的指数位是 -3，有效位也还是 00…（后面全是 0，记住 f 前默认有一个 1）

> 计算 0.5+0.125 的浮点数运算的时候，首先要把两个的指数位对齐，也就是把指数位都统一成两个其中较大的 -1。对应的有效位 1.00…也要对应右移两位，因为 f 前面有一个默认的 1，所以就会变成 0.01。然后我们计算两者相加的有效位 1.f，就变成了有效位 1.01，而指数位是 -1