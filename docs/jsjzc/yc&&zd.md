### 异常来源
- 硬件来源：算术溢出，键盘信号输入
- 软件来源：应用程序系统调用

### 异常
- 一个硬件和软件组合到一起的处理过程
- 异常的发生和捕捉是发生在硬件层面
- 异常的处理是由软件完成的

### 异常代码
- 也叫中断向量
- 计算机会为每一种异常，分配一个异常代码
- 异常发生的时候，通常是CPU检测到了一个输出的异常代码（信号）
- I/O发出的信号的异常代码是操作系统来分配的，也就是由软件来完成设定的
- 加法溢出这种异常，是CPU预先分配好的，由硬件分配

### 异常表
- expection table
- 也叫中断向量表
- 存储异常代码合对应的异常处理程序的地址
- 拿到异常代码后，CPU会触发异常处理流程，然后根据异常代码，查询异常表
- 找到异常处理程序所在的地址
![](http://image.heysq.com/wiki/jsjzc/yichangliucheng.jpeg)

### 异常分类
- 中断 Interrupt
- 陷阱 Trap
- 故障 Fault
- 中止 Abort

#### 中断
- 程序执行过程中被打断
- 打断执行的信号来自于CPU外部的io设备

#### 陷阱
- 故意主动触发的异常
- 程序发生系统调用的时候，也就是程序从用户态切换到内核态的时候会产生缺陷
- 应用程序读取文件，创建进程，也是通过触发一个陷阱来进行的，应为用户态的程序没有权限，只能通过陷阱处理程序来进行高权限操作

#### 故障
- 不是故意主动触发的，
- 不在开发计划内的异常
- 异常程序处理完之后，仍然回来处理当前的指令，而不是去执行下一条指令

#### 中止
- CPU遇到了故障，并且故障无法恢复

![](http://image.heysq.com/wiki/jsjzc/yichangdetail.jpeg)

### 异常处理-上下文切换
- 切换到异常处理程序的时候，像是去调用一个异常处理函数
- 指令的控制权被切换到了另外一个"函数"里面，要把当前正在执行的指令去压栈
- 在异常处理程序执行完成之后，重新回到当前的指令继续往下执行
- 比如中断、故障发生的时候，除了本来程序压栈要做的事情之外，还需要把 CPU 内当前运行程序用到的所有寄存器，都放到栈里面
- 像陷阱这样的异常，涉及程序指令在用户态和内核态之间的切换。对应压栈的时候，对应的数据是压到内核栈里，而不是程序栈里
- 像故障这样的异常，在异常处理程序执行完成之后。从栈里返回出来，继续执行的不是顺序的下一条指令，而是故障发生的当前指令。因为当前指令因为故障没有正常执行成功，必须重新去执行一次