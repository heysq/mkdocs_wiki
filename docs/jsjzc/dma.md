### 主设备和从设备
- 总线上的设备的两种类型
- 要想发起数据传输，必须要是一个主设备才行
- CPU就是主设备，从设备（硬盘）只能接受数据传输
- io设备不能向主设备发发起数据传送，而是发送一个控制信号，告知主设备进行数据拉取
- 要么是CPU向io设备写数据，要么是CPU从io设备拉数据

### 直接内存访问
- Direct Memory Access
- 减少iowait时，cpu等待的时间
- DMA技术就是独立在主板上放一个芯片
- 进行内存和IO设备数据传输的时候，不再通过CPU控制数据传输，而是通过DMA控制器 DMA Controller 简称DMAC
- DMAC 是一种特殊的IO设备，它和CPU通信和其他io设备一样，都是通过总线进行实际的数据传输

#### DMAC
- 相对CPU是从设备
- 相对硬盘是主设备

### 传输过程
1. 首先，CPU 还是作为一个主设备，向 DMAC 设备发起请求。这个请求，其实就是在 DMAC 里面修改配置寄存器
2.  CPU 修改 DMAC 的配置的时候，会告诉 DMAC 这样几个信息：
    - 首先是源地址的初始值以及传输时候的地址增减方式。就是数据要从哪里传输过来
    - 如果我们要从内存里面写入数据到硬盘上，那么就是要读取的数据在内存里面的地址
    - 如果是从硬盘读取数据到内存里，那就是硬盘的 I/O 接口的地址。
    - I/O 的地址可以是一个内存地址，也可以是一个端口地址。而地址的增减方式就是说，数据是从大的地址向小的地址传输，还是从小的地址往大的地址传输
    - 其次是目标地址初始值和传输时候的地址增减方式。目标地址自然就是和源地址对应的设备，也就是我们数据传输的目的地
    - 第三个是要传输的数据长度，也就是一共要传输多少数据
3. 设置完这些信息之后，DMAC 就会变成一个空闲的状态（Idle）
4. 如果我们要从硬盘上往内存里面加载数据，这个时候，硬盘就会向 DMAC 发起一个数据传输请求。这个请求并不是通过总线，而是通过一个额外的连线
5. DMAC需要再通过一个额外的连线响应这个申请
6. DMAC就向硬盘的接口发起要总线读的传输请求。数据就从硬盘里面，读到了 DMAC 的控制器里面
7. DMAC再向我们的内存发起总线写的数据传输请求，把数据写入到内存里面
8. DMAC 会反复进行上面第 6、7 步的操作，直到 DMAC 的寄存器里面设置的数据长度传输完成
9. 数据传输完成之后，DMAC 重新回到第 3 步的空闲状态
![](http://image.heysq.com/wiki/jsjzc/dmac.jpeg)

### kafka用DMA加速
- 本地硬盘传输到网卡设备
- 四次传输，两次DMA控制的传输，两次CPU控制的传输
- 第一次传输，是从硬盘上，读到操作系统内核的缓冲区里。这个传输是通过 DMA 搬运的
- 第二次传输，需要从内核缓冲区里面的数据，复制到我们应用分配的内存里面。这个传输是通过 CPU 搬运的
- 第三次传输，要从我们应用的内存里面，再写到操作系统的 Socket 的缓冲区里面去。这个传输，还是由 CPU 搬运的
- 最后一次传输，需要再从 Socket 的缓冲区里面，写到网卡的缓冲区里面去。这个传输又是通过 DMA 搬运的
![](http://image.heysq.com/wiki/jsjzc/kafka_dma.jpg)

#### kafka加速——零拷贝 zero copy
```java

@Override
public long transferFrom(FileChannel fileChannel, long position, long count) throws IOException {
    return fileChannel.transferTo(position, count, socketChannel);
}
```

- 调用 Java 的NIO库
- 硬盘的数据并没有写到中间的应用内存
- 直接通过Channel写入到对应的网络设备里
- socker的内容也不是写入到socker的buffer中
- 直接根据描述符写到网卡的缓冲区里
- 没有在内存层面去“复制（Copy）”数据
![](http://image.heysq.com/wiki/jsjzc/kafkajiasu.jpg)